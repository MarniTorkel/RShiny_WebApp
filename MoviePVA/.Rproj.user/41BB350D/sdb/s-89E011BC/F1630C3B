{
    "collab_server" : "",
    "contents" : "# ==========================================================\n# COMP5703 - IT CAPSTONE PROJECT - MOVIE VISUAL ANALYTICS\n# ==========================================================\n#\nsource(\"Global.R\")\n#library(ggplot2movies)\nlibrary(randomcoloR)\nlibrary(dplyr)\nlibrary(scales)\nlibrary(stringr)\nlibrary(fastmatch)\nlibrary(ggplot2)\nlibrary(ggTimeSeries)\nlibrary(ggthemes)\n#library(streamgraph)\nlibrary(htmlwidgets)\n#library(plotly)\nlibrary(bubbles)\nlibrary(wordcloud)\nlibrary(RColorBrewer)\nlibrary(NLP)\nlibrary(tm)\nlibrary(networkD3)\n#library(sigma)\n#library(rgexf)\n#library(visNetwork)\n#library(igraph)\nlibrary(sunburstR)\nlibrary(DT)\n#library(ndtv)\nlibrary(network)\nlibrary(sna)\nlibrary(networkDynamic)\nlibrary(animation)\n#library(lazyeval)\n#library(dygraphs)\npackageVersion(\"streamgraph\")\n#library(df2json)\nlibrary(ggraph)\nlibrary(ggforce)\nlibrary(gganimate)\nlibrary(igraph)\nlibrary(ggnet)\nlibrary(GGally)\nlibrary(intergraph)\nlibrary(ggrepel)\nlibrary(edgebundleR)\n\nshinyServer(function(input, output, session) {\n  # =========== OVERVIEW ============\n  \n  # dataInput <- reactive({\n  #   switch(input$variable,\n  #          \"Actor\"=\"actors\",\n  #          \"Directors\"=\"directors\",\n  #          \"Director Average Ratings\"=\"dar\",\n  #          \"Director Average Revenue\"=\"darev\",\n  #          \"Revenue in years\"=\"riy\",\n  #          \"IMDB Ratings\"=\"ratings\",\n  #          \"Genres\"=\"genres\",\n  #          \"Title years\"= \"year\")\n  # })\n  \n  # output$varPlot <- renderPlot({\n  # switch(dataInput,\n  #        \"actors\"={\n  #          actor_names <- data.frame(imdb_data$actor_1_name, imdb_data$actor_2_name, imdb_data$actor_3_name)\n  #          actor_fb_likes <- data.frame(imdb_data$actor_1_facebook_likes, imdb_data$actor_2_facebook_likes, imdb_data$actor_3_facebook_likes)\n  #          unlist_actor_names <- data.frame(unlist(actor_names))\n  #          colnames(unlist_actor_names) <- \"name\"\n  #          unlist_actor_fb_likes <- unlist(actor_fb_likes)\n  #          unlist_actor_names_freq <- dplyr::count(unlist_actor_names, name) \n  #          unlist_actor_names_freq <- unlist_actor_names_freq[order(-unlist_actor_names_freq[,2]),]\n  #          actor_fb <- data.frame(unlist_actor_names, unlist_actor_fb_likes)\n  #          actor_fb <- unique(actor_fb[order(-actor_fb[,2]),])\n  #          rownames(actor_fb) <- NULL\n  #          colnames(actor_fb) <- c(\"name\", \"fb\")\n  #          output$dataMes <- renderText({\n  #            return(\"Actor name frequencies\")\n  #          })\n  #          output$varList <- renderPlot({\n  #            wordcloud::wordcloud(unlist_actor_names_freq[1:50,]$name, unlist_actor_names_freq[1:50,]$n, colors = brewer.pal(8, \"Dark2\"), scale=c(1.5,0.2)) \n  #          })\n  #          \n  #          #output$varPlot <- renderPlot({\n  #            wordcloud::wordcloud(actor_fb[1:50,]$name, actor_fb[1:50,]$fb, colors = brewer.pal(8, \"Dark2\"), scale=c(1.5,0.2)) \n  #          #}) \n  #          print(\"Actors\")\n  #        },\n  #        \"directors\"={\n  #          print(\"Directors\")\n  #        },\n  #        \"dar\"={\n  #          print(\"\")\n  #        },\n  #        \"Darev\"={\n  #          print(\"\")\n  #        },\n  #        \"riy\"={\n  #          print(\"\")\n  #        },\n  #        \"ratings\"={\n  #          print(\"\")\n  #        },\n  #        \"genres\"={\n  #          print(\"\")\n  #        },\n  #        \"years\"={\n  #          print(\"\")\n  #        }\n  #        )\n  # })\n  variablename <- reactive({\n    paste0(str_to_title(gsub(\"_\", \" \", input$variable)))\n  })\n  \n  output$caption <- renderText({\n    paste0(\"Visualisation - \",variablename())\n  })\n  \n  output$varList <- renderPrint({\n    num <- fmatch(input$variable, names(imdb_data))\n    if (class(imdb_data[[num]]) == \"character\") {\n      if (input$variable == \"movie_title\")\n      {\n        output$dataMes <- renderText({\n          return(\"Top revenue movies\")\n        })\n        # http://www.sthda.com/english/wiki/text-mining-and-word-cloud-fundamentals-in-r-5-simple-steps-you-should-know\n        # Split the words into individual word\n        # docs <- Corpus(VectorSource(imdb_data[[num]]))\n        # # Convert the text to lower case\n        # docs <- tm_map(docs, content_transformer(tolower))\n        # # Remove english common stopwords\n        # docs <- tm_map(docs, removeWords, stopwords(\"english\"))\n        # # Remove punctuations\n        # docs <- tm_map(docs, removePunctuation)\n        # # Eliminate extra white spaces\n        # docs <- tm_map(docs, stripWhitespace)\n        # dtm <- TermDocumentMatrix(docs)\n        # m <- as.matrix(dtm)\n        # v <- sort(rowSums(m),decreasing=TRUE)\n        # titleDat <- data.frame(word = names(v),freq=v)\n        title_rev <- data.frame(imdb_data$movie_title, round(imdb_data$gross/1000000,0))\n        title_rev <- unique(title_rev[order(-title_rev[,2]),])\n        colnames(title_rev) <- c(\"Title\", \"Gross(m)\")\n        rownames(title_rev) <- NULL\n        return(title_rev[1:4,])\n      }\n      else if (input$variable == \"director_name\") {\n        output$dataMes <- renderText({\n          return(\"Top revenue directors\")\n        })\n        dir_rev <- data.frame(imdb_data$director_name, round(imdb_data$gross/1000000,0))\n        dir_rev <- unique(dir_rev[order(-dir_rev[,2]),])\n        colnames(dir_rev) <- c(\"Director\", \"Gross(m)\")\n        rownames(dir_rev) <- NULL\n        return(dir_rev[1:9,])\n      }\n      else {\n        output$dataMes <- renderText({\n          return(\"Data Frequency\")\n        })\n        if (input$variable == \"plot_keywords\")\n        {\n            # Split the words into individual word\n            words <- strsplit(as.character(imdb_data[[num]]), split=\"\\\\|\")\n            word_df <- data.frame(unlist(words))\n            names(word_df) <- \"words\"\n            catDat <- dplyr::count(word_df, words)\n            catDat <- data.frame(catDat[order(-catDat[,2]),])\n            return(head(catDat))\n        }\n        else {\n            return(head(as.data.frame(sort(table(imdb_data[[num]]),decreasing = TRUE))))\n        }\n\n      }\n    }\n    else {\n      output$dataMes <- renderText({\n        return(\"Summary\")\n      })\n      return(summary(imdb_data[num]))\n    }\n  })\n\n  \n  output$varPlot <- renderPlot({\n    num <- fmatch(input$variable, names(imdb_data))\n    if (class(imdb_data[[num]]) == \"character\") {\n      if (input$variable %in% c(\"genres\", \"plot_keywords\"))\n      {\n        # Split the words into individual word\n        words <- strsplit(as.character(imdb_data[[num]]), split=\"\\\\|\")\n        word_df <- data.frame(unlist(words))\n        names(word_df) <- \"words\"\n        catDat <- dplyr::count(word_df, words)\n        catDat <- catDat[order(-catDat[,2]),]\n      }\n      else if (input$variable %in% \"movie_title\"){\n          # http://www.sthda.com/english/wiki/text-mining-and-word-cloud-fundamentals-in-r-5-simple-steps-you-should-know\n          # Split the words into individual word\n          # docs <- Corpus(VectorSource(imdb_data[[num]]))\n          # # Convert the text to lower case\n          # docs <- tm_map(docs, content_transformer(tolower))\n          # # Remove english common stopwords\n          # docs <- tm_map(docs, removeWords, stopwords(\"english\"))\n          # # Remove punctuations\n          # docs <- tm_map(docs, removePunctuation)\n          # # Eliminate extra white spaces\n          # docs <- tm_map(docs, stripWhitespace)\n          # dtm <- TermDocumentMatrix(docs)\n          # m <- as.matrix(dtm)\n          # v <- sort(rowSums(m),decreasing=TRUE)\n          # catDat <- data.frame(word = names(v),freq=v)\n          title_revenue <- data.frame(imdb_data$movie_title, imdb_data$gross/1000000)\n          catDat <- data.frame(title_revenue[order(-title_revenue[,2]),])\n          rownames(catDat) <- NULL\n      }\n      else if (input$variable %in% \"director_name\"){\n        dir_revenue <- data.frame(imdb_data$director_name, imdb_data$gross/1000000)\n        colnames(dir_revenue) <- c(\"director\", \"revenue\")\n        #dir_agg <- aggregate(revenue ~ director, dir_revenue, sum)\n        catDat <- data.frame(dir_revenue[order(-dir_revenue[,2]),])\n        rownames(catDat) <- NULL\n      }\n      else  {\n        catDat <- as.data.frame(sort(table(imdb_data[[num]]),decreasing = TRUE))\n      }\n      names(catDat) <- c(\"words\", \"freq\")\n      # word cloud\n      if (nrow(catDat) > 50)\n      {\n        wordcloud::wordcloud(catDat[1:50,]$words, catDat[1:50,]$freq, colors = brewer.pal(8, \"Dark2\"), scale=c(1.8,0.2))\n      }\n      else {\n        wordcloud::wordcloud(catDat$words, catDat$freq, colors = brewer.pal(8, \"Dark2\"),scale=c(4,1))\n      }\n\n    }\n    else {\n      if (input$variable %in% \"gross\") {\n        return(ggplot(imdb_data, aes(x = imdb_data$title_year)) + \n                 geom_line(aes(y = imdb_data$gross), colour=\"#DD8888\") + \n                 ylab(label=\"Revenue\") + \n                 xlab(\"Year\") + ggtitle(\"Box office revenue vs year\")+theme(plot.background = element_blank(),\n                                                                            panel.background = element_blank(),\n                                                                            panel.border = element_blank(),\n                                                                            plot.title = element_text(color = \"#000000\"),\n                                                                            legend.position = \"none\"))\n      } else {\n        return(ggplot(imdb_data, aes(imdb_data[[num]])) + geom_histogram(aes(y = ..density..), color=\"black\", fill=\"#DD8888\") + xlab(input$variable) +theme(plot.background = element_blank(),\n                                                                                                                                                         panel.background = element_blank(),\n                                                                                                                                                         panel.border = element_blank(),\n                                                                                                                                                         plot.title = element_text(color = \"#000000\"),\n                                                                                                                                                         legend.position = \"none\"))\n      }\n    }\n\n  })\n  \n  # ========= CO-STARRING NETWORK ============\n  \n  \n  # degrees\n  #output$degree_value <- renderPrint({return(input$degrees)})\n  output$degree_value <- renderPrint({\n    minDegree <- min(g_nodes$degree, na.rm = TRUE)\n    maxDegree <- max(g_nodes$degree)\n    degreeRange <- c(minDegree, maxDegree)\n    return(input$degrees)})\n  \n   \n    ratings <- reactive({\n      return(input$ratings)\n    })\n    \n    years <- reactive({\n      return(input$years)\n    })\n    \n    movie_years <- reactive({\n      return(input$movie_years)\n    })\n    \n    genre <- reactive({\n      return(input$genre)\n    })\n    \n    movie_genres <- reactive({\n      return(input$movie_genres)\n    })\n    \n    gross <- reactive({\n        return(input$gross)\n    })\n    \n    output$rnet <- renderForceNetwork({\n      # detach(\"package:ndtv\")\n      # detach(\"package:sna\")\n      # detach(\"package:networkDynamic\")\n      # detach(\"package:network\")\n      # detach(\"package:animation\")\n      library(igraph)\n      library(networkD3)\n      nodes_links <- getNL(ratings(), years(), genre(), gross())\n      network_nodes <- nodes_links$nodes\n      network_links <- nodes_links$links\n      \n      # Generate degrees\n      graph <- graph_from_data_frame(network_links, directed = FALSE, vertices = network_nodes)\n      network_nodes$degree <- igraph::degree(graph, mode=\"all\")\n      network_nodes$closeness <- igraph::closeness(graph, mode = \"all\")\n      network_nodes$coreness = graph.coreness(as.undirected(graph))\n      network_nodes$betweenness <- rescale(igraph::betweenness(graph, normalized = TRUE), to=c(0,200))\n      \n      # Select up to 100 nodes based on degrees\n      #maxDeg <- max(network_nodes$degree)\n      #deg <- c(as.integer(maxDeg*0.2), maxDeg)\n      network_nodes <- network_nodes[ order(-network_nodes[,3]), ]\n      if (nrow(network_nodes) > 100) {\n          network_nodes <- network_nodes[1:100,]\n      }\n      #network_nodes <- subset(network_nodes, network_nodes$degree >= deg[1] & network_nodes$degree <= deg[2])\n      network_links <- network_links[network_links$from %in% network_nodes$id,]\n      network_links <- network_links[network_links$to %in% network_nodes$id,]\n      row.names(network_links) <- NULL\n      row.names(network_nodes) <- NULL\n      # Reset index for nodes and links\n      idn <- as.numeric(rownames((network_nodes))) - 1\n      network_nodes <- cbind(idn, network_nodes)\n      from2 <- data.frame(from=network_nodes[match(network_links$from, network_nodes$id), 1])\n      to2 <- data.frame(to=network_nodes[match(network_links$to, network_nodes$id), 1])\n      network_links <- cbind(from2, to2, network_links$value)\n      network_nodes <- within(network_nodes, rm(id))\n      colnames(network_nodes)[1] <- 'id'\n      colnames(network_links)[3] <- 'value'\n      # recalculate centrality\n      graph2 <- graph_from_data_frame(network_links, directed = FALSE, vertices = network_nodes)\n      graph2 <- simplify(graph2)\n      network_nodes$degree <- igraph::degree(graph2, mode=\"all\")\n      network_nodes$closeness <- igraph::closeness(graph2, mode = \"all\")\n      network_nodes$coreness = graph.coreness(as.undirected(graph2))\n      network_nodes$betweenness <- rescale(igraph::betweenness(graph2, normalized = TRUE), to=c(0,200))\n      \n      # Community\n      network_nodes$edgebetweenness <- as.integer(edge.betweenness.community(graph2)$membership)\n      network_nodes$walktrap <- as.integer(walktrap.community(graph2, steps=10,modularity=TRUE)$membership)\n      network_nodes$fastgreedy <- as.integer(cluster_fast_greedy(graph2)$membership)\n      # jump to Temporal Dynamic page\n      goTemporal <- \"d3.selectAll('.node').on(click, function(d) {alert(d.name);})\"\n        #observeEvent({\n       # goTemporal <- $(document).on('shiny:inputchanged', function(event) {\n       #   \n       # })\n\n       #$('#td_actor').value(d.name);\n       #$('#search').click('press');\n       #$('#tda_actor').modal('show');\n        # newtab <- switch(\"costar\" = \"temporal\",\"temporal\" = \"costar\")\n        # updateTabItems(session, \"temporal\", newtab)\n        #'alert(d.index);'\n        #\"d3.selectAll('.node').on(click, function(d) {alert(d.name);})\"\n       # $(\"#tda_actor\").modal('show');  \n          #actionButton('switchtab', \"ClickAction on force Network\")\n          #observeEvent(input$switchtab, {\n          #newtab <- switch(input$tabs, \"costar\" = \"temporal\", \"temporal\" = \"costar\")\n          #updateTabItems(session, \"tabs\", newtab)\n          #})\n      #})\n      output$i_actors <- renderText({\n          influencers <- network_nodes[ order(-network_nodes[,which(colnames(network_nodes) ==input$centrality)]), ]\n          paste0(as.character(influencers[1:5,]$name), collapse=\"\\n\")\n          #head(influencers$name)\n      })\n      \n      observe({\n          influencers <- network_nodes[ order(-network_nodes[,which(colnames(network_nodes) == input$centrality)]), ]\n          updateSelectInput(session, \"td_actor\", choices = as.list(influencers[1:5,]$name))\n          #input$topActors\n      })\n      \n\n      # Force network\n      forceNetwork(Links = network_links, Nodes = network_nodes, Source = \"from\", Target = \"to\", Value = \"value\",  \n                   NodeID = \"name\", Group = input$community, linkWidth =   JS(\"function(d) { return d.value; }\"), \n                   charge=-20,zoom=T, clickAction = goTemporal,  \n                   Nodesize = input$centrality, fontSize=20, opacity = 0.8, width = NULL, height = NULL)\n      \n    })\n    \n    \n\n#================= EGO NETWORK ANALYSIS ====================\n    observeEvent(input$switchtab, {\n        newtab <- switch(input$tabs, \"costar\" = \"temporal\", \"temporal\" = \"costar\")\n        updateTabItems(session, \"tabs\", newtab)\n    })\n    # observe({\n    #   updateTextInput(session, 'td_actor', value=\"\")\n    # })\n    \n    # Get input name\n    td_actor <- eventReactive(input$search,{\n        if (input$td_actor %in% actorList[,1]) {\n            return(input$td_actor)\n        }\n        else {\n            return(\"\")\n        }\n    })\n    \n    # get input data\n    tda_data <- eventReactive(input$search,{\n        if (td_actor() %in% actorList[,1]) {\n            getActor(td_actor())\n        }\n        else {\n            return(NULL)\n        }\n    })\n    \n    \n\n    output$search_status <- renderText({\n        if (td_actor() != \"\"){\n            paste0(td_actor(), \" found\")\n        }\n        else {\n            paste0(\"Actor not found\")\n        }\n    })\n    \n    output$boPlot <- renderPlot({\n      if (!is.null(tda_data())) {\n        td_actors <- data.frame(tda_data()$td_data.movie_title, tda_data()$td_data.actor_1_name, tda_data()$td_data.actor_2_name, tda_data()$td_data.actor_3_name)\n        colnames(td_actors)[1] <- \"actor\"\n        # co-actors\n        td_co_actors <- melt(td_actors, id.vars = \"actor\")\n        names(td_co_actors) <- c(\"movie_title\", \"a_num\", \"actor\")\n        # add years\n        td_years <- data.frame(year=tda_data()[match(td_co_actors$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_actor <- cbind(td_co_actors[,3], td_years)\n        # add gross\n        m_y <- cbind(td_co_actors[,1], td_years)\n        td_gross <- data.frame(gross=tda_data()[match(td_co_actors$movie_title, tda_data()$td_data.movie_title), 9])\n        gross_year <- cbind(m_y[,2], round(td_gross/1000000, 0))\n        gross_year$gross <- as.integer(gross_year$gross)\n        colnames(gross_year) <- c(\"year\", \"gross\")\n        g <- ggplot(gross_year, aes(x = year, y = gross, fill=year)) + \n          geom_line() +\n          geom_point() +\n          theme_classic() + scale_colour_gradientn(colours=rainbow(4)) \n        g\n      \n      }  \n    })\n    \n    output$tdnet <- renderForceNetwork({\n      if (!is.null(tda_data())) {\n        td_actors <- data.frame(tda_data()$td_data.movie_title, tda_data()$td_data.actor_1_name, tda_data()$td_data.actor_2_name, tda_data()$td_data.actor_3_name)\n        colnames(td_actors)[1] <- \"actor\"\n        # co-actors\n        td_co_actors <- melt(td_actors, id.vars = \"actor\")\n        names(td_co_actors) <- c(\"movie_title\", \"a_num\", \"actor\")\n        # add years\n        td_years <- data.frame(year=tda_data()[match(td_co_actors$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_actor <- cbind(td_co_actors[,3], td_years)\n        \n        tda_actor <- aggregate(year ~ ., tda_actor, toString)\n        #tda_actor <- as.data.frame(td_co_actors[,3], stringsAsFactors = FALSE)\n        #tda_actor <- unique(tda_actor)\n        tda_actor <- tda_actor[ order(tda_actor[,1]), ]\n        actors_id <- 0:(nrow(tda_actor)-1)\n        # nodes\n        tda_nodes <- data.frame(actors_id, tda_actor)\n        colnames(tda_nodes) <- c(\"id\", \"name\", \"years\")\n        tda_nodes$name <- as.character(tda_nodes$name)\n        rownames(tda_nodes) <- NULL\n        # Links\n        td_links <- td_co_actors[,c(1,3)]\n        names(td_links) <- c(\"movie_title\", \"name\")\n        # change name column 2 to id as from actors_nodes\n        td_links_id <- data.frame(movie_title=td_links$movie_title, id= tda_nodes[match(td_links$name, tda_nodes$name), 1])\n        td_links_merge <- merge(x=td_links_id, y=td_links_id, by=\"movie_title\")\n        td_links_merge <- subset(td_links_merge, td_links_merge$id.x != td_links_merge$id.y)\n        # add years  \n        td_years <- data.frame(year=tda_data()[match(td_links_merge$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_links <- as.data.frame(c(td_links_merge[,c(2,3)], td_years), stringsAsFactors = FALSE)\n        # sort links\n        tda_links <- tda_links[ order(tda_links[,1], tda_links[,2]), ]\n        #names(tda_links) <- c(\"tail\", \"head\", \"onset\", \"terminus\")\n        names(tda_links) <- c(\"from\", \"to\", \"year\")\n        # Add weight to data frame\n        #value <- count(tda_links, c(\"from\", \"to\"))\n        \n        rownames(tda_links) <- NULL\n        # Graph\n        tda_graph <- graph_from_data_frame(tda_links, directed = FALSE, vertices = tda_nodes)\n        tda_nodes$degree <- igraph::degree(tda_graph, mode=\"all\")\n        plot.igraph(tda_graph, \n                    vertex.label = V(tda_graph)$name, vertex.label.color = \"gray20\",\n                    vertex.size = tda_nodes$degree, vertex.size2 = 30,\n                    vertex.color = \"gray90\", vertex.frame.color = \"gray20\",\n                    vertex.shape = \"rectangle\",\n                    edge.arrow.size=0.5, edge.color=col, #edge.width = E(g)$weight / 10,\n                    edge.curved = T, \n                    layout = layout.reingold.tilford)\n        \n       \n        \n      }\n    })\n    \n    output$ggPlots <- renderPlot({\n      if (!is.null(tda_data())) {\n        td_actors <- data.frame(tda_data()$td_data.movie_title, tda_data()$td_data.actor_1_name, tda_data()$td_data.actor_2_name, tda_data()$td_data.actor_3_name)\n        colnames(td_actors)[1] <- \"actor\"\n        # co-actors\n        td_co_actors <- melt(td_actors, id.vars = \"actor\")\n        names(td_co_actors) <- c(\"movie_title\", \"a_num\", \"actor\")\n        # add years\n        td_years <- data.frame(year=tda_data()[match(td_co_actors$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_actor <- cbind(td_co_actors[,3], td_years)\n        tda_actor <- aggregate(year ~ ., tda_actor, toString)\n        #tda_actor <- as.data.frame(td_co_actors[,3], stringsAsFactors = FALSE)\n        #tda_actor <- unique(tda_actor)\n        tda_actor <- tda_actor[ order(tda_actor[,1]), ]\n        actors_id <- 1:(nrow(tda_actor))\n        # nodes\n        tda_nodes <- data.frame(actors_id, tda_actor)\n        colnames(tda_nodes) <- c(\"id\", \"name\", \"years\")\n        tda_nodes$name <- as.character(tda_nodes$name)\n        rownames(tda_nodes) <- NULL\n        \n        td_links <- td_co_actors[,c(1,3)]\n        names(td_links) <- c(\"movie_title\", \"name\")\n        # change name column 2 to id as from actors_nodes\n        td_links_id <- data.frame(movie_title=td_links$movie_title, id= tda_nodes[match(td_links$name, tda_nodes$name), 1])\n        td_links_merge <- merge(x=td_links_id, y=td_links_id, by=\"movie_title\")\n        td_links_merge <- subset(td_links_merge, td_links_merge$id.x != td_links_merge$id.y)\n        # add range of years\n        td_years <- data.frame(year=tda_data()[match(td_links_merge$movie_title, tda_data()$td_data.movie_title), 7])\n        td_years$bin <- ifelse(td_years$year < 1990, \"Pre 1990\",\n                        ifelse(td_years$year >= 1990 & td_years$year < 2000, \"1990-1999\",\n                        ifelse(td_years$year >= 2000 & td_years$year < 2010, \"2000-2009\",\n                        ifelse(td_years$year >= 2010, \"2010-2016\",\n                        NA  ))))\n        tda_links <- as.data.frame(c(td_links_merge[,c(2,3)], td_years), stringsAsFactors = FALSE)\n        # sort links\n        tda_links <- tda_links[ order(tda_links[,1], tda_links[,2]), ]\n        names(tda_links) <- c(\"from\", \"to\", \"year\", \"range\")\n        rownames(tda_links) <- NULL\n        \n        graph <- graph_from_data_frame(d=tda_links, vertices=tda_nodes, directed=F)\n        tda_nodes$degree <- igraph::degree(graph, mode=\"all\")\n        \n        p <- ggraph(graph, layout=\"kk\") + \n          geom_edge_link(aes(alpha=..index.., colour=factor(tda_links$range))) + \n          geom_edge_fan(aes(colour=factor(tda_links$range)))\n          #geom_node_point(aes(size = tda_nodes$degree)) + #scale_edge_alpha(guide=\"None\") +\n          geom_node_point() +\n          theme_graph() \n        p + facet_edges( ~ tda_links$range, ncol = 2)\n         \n      }\n    })\n    \n    output$smPlots <- renderPlot({\n      if (!is.null(tda_data())) {\n        td_actors <- data.frame(tda_data()$td_data.movie_title, tda_data()$td_data.actor_1_name, tda_data()$td_data.actor_2_name, tda_data()$td_data.actor_3_name)\n        colnames(td_actors)[1] <- \"actor\"\n        # co-actors\n        td_co_actors <- melt(td_actors, id.vars = \"actor\")\n        names(td_co_actors) <- c(\"movie_title\", \"a_num\", \"actor\")\n        # add years\n        td_years <- data.frame(year=tda_data()[match(td_co_actors$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_actor <- cbind(td_co_actors[,3], td_years)\n        tda_actor <- aggregate(year ~ ., tda_actor, toString)\n        #tda_actor <- as.data.frame(td_co_actors[,3], stringsAsFactors = FALSE)\n        #tda_actor <- unique(tda_actor)\n        tda_actor <- tda_actor[ order(tda_actor[,1]), ]\n        actors_id <- 1:(nrow(tda_actor))\n        # nodes\n        tda_nodes <- data.frame(actors_id, tda_actor)\n        colnames(tda_nodes) <- c(\"id\", \"name\", \"years\")\n        tda_nodes$name <- as.character(tda_nodes$name)\n        rownames(tda_nodes) <- NULL\n        \n        td_links <- td_co_actors[,c(1,3)]\n        names(td_links) <- c(\"movie_title\", \"name\")\n        # change name column 2 to id as from actors_nodes\n        td_links_id <- data.frame(movie_title=td_links$movie_title, id= tda_nodes[match(td_links$name, tda_nodes$name), 1])\n        td_links_merge <- merge(x=td_links_id, y=td_links_id, by=\"movie_title\")\n        td_links_merge <- subset(td_links_merge, td_links_merge$id.x != td_links_merge$id.y)\n        # add years\n        td_years <- data.frame(year=tda_data()[match(td_links_merge$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_links <- as.data.frame(c(td_links_merge[,c(2,3)], td_years), stringsAsFactors = FALSE)\n        # sort links\n        tda_links <- tda_links[ order(tda_links[,1], tda_links[,2]), ]\n        names(tda_links) <- c(\"from\", \"to\", \"year\")\n        rownames(tda_links) <- NULL\n        # Setup network\n        net <- network(tda_links,  vertex.attr=tda_nodes, matrix.type=\"edgelist\", \n                        loops=F, multiple=F, ignore.eval = F)\n        # Setup initial layout\n        x <- gplot.layout.fruchtermanreingold(net, NULL)\n        net %v% \"x\" <- x[,1]\n        net %v% \"y\" <- x[,2]\n        # Setup attributes\n        # Get weight\n        #net %e% \"weights\" <- \n        # Setup period\n        t1 <- c(1927:1979)\n        t1_value <- c()\n        for (i in tda_nodes$years) {\n          c <- unlist(strsplit(i, \",\"))\n          if (any(trimws(c) %in% t1)) {\n            t1_value <- c(t1_value, 1)\n          }\n          else {\n            t1_value <- c(t1_value, 2)\n          }\n        }\n        net %v% 't1' <- t1_value\n        \n        t2 <- c(1980:1989)\n        t2_value <- c()\n        for (i in tda_nodes$years) {\n          c <- unlist(strsplit(i, \",\"))\n          if (any(trimws(c) %in% t2)) {\n            t2_value <- c(t2_value, 1)\n          }\n          else {\n            t2_value <- c(t2_value, 2)\n          }\n        }\n        net %v% 't2' <- t2_value\n        \n        t3 <- c(1990:1999)\n        t3_value <- c()\n        for (i in tda_nodes$years) {\n          c <- unlist(strsplit(i, \",\"))\n          if (any(trimws(c) %in% t3)) {\n            t3_value <- c(t3_value, 1)\n          }\n          else {\n            t3_value <- c(t3_value, 2)\n          }\n        }\n        net %v% 't3' <- t3_value\n        \n        t4 <- c(2000:2009)\n        t4_value <- c()\n        for (i in tda_nodes$years) {\n          c <- unlist(strsplit(i, \",\"))\n          if (any(trimws(c) %in% t4)) {\n            t4_value <- c(t4_value, 1)\n          }\n          else {\n            t4_value <- c(t4_value, 2)\n          }\n        }\n        net %v% 't4' <- t4_value\n        t5 <- c(2010:2016)\n        t5_value <- c()\n        for (i in tda_nodes$years) {\n          c <- unlist(strsplit(i, \",\"))\n          if (any(trimws(c) %in% t5)) {\n            t5_value <- c(t5_value, 1)\n          }\n          else {\n            t5_value <- c(t5_value, 2)\n          }\n        }\n        net %v% 't5' <- t5_value\n        \n        guide <- guides(color = FALSE, size = FALSE)\n        \n        net %v% \"color\" = ifelse(net %v% \"t1\" == \"1\", \"purple\", \"lightgray\")\n        g1 <- ggnet2(net, mode=c(\"x\",\"y\"), size = \"degree\", label=T, label.size = 4, label.color=\"white\", edge.color = c(\"color\", \"grey50\"), color = \"color\") + guide\n        net %v% \"color\" = ifelse(net %v% \"t2\" == \"1\", \"purple\", \"lightgray\")\n        g2 <- ggnet2(net, mode=c(\"x\",\"y\"), size = \"degree\", label=T, label.size = 4, label.color=\"white\", edge.color = c(\"color\", \"grey50\"), color = \"color\") + guide\n        net %v% \"color\" = ifelse(net %v% \"t3\" == \"1\", \"purple\", \"lightgray\")\n        g3 <- ggnet2(net, mode=c(\"x\",\"y\"), size = \"degree\", label=T, label.size = 4, label.color=\"white\", edge.color = c(\"color\", \"grey50\"), color = \"color\") + guide\n        net %v% \"color\" = ifelse(net %v% \"t4\" == \"1\", \"purple\", \"lightgray\")\n        g4 <- ggnet2(net, mode=c(\"x\",\"y\"), size = \"degree\", label=T, label.size = 4, label.color=\"white\", edge.color = c(\"color\", \"grey50\"), color = \"color\") + guide\n        net %v% \"color\" = ifelse(net %v% \"t5\" == \"1\", \"purple\", \"lightgray\")\n        g5 <- ggnet2(net, mode=c(\"x\",\"y\"), size = \"degree\", label=T, label.size = 4, label.color=\"white\", edge.color = c(\"color\", \"grey50\"), color = \"color\") + guide\n        \n        gridExtra::grid.arrange(g1 + ggtitle(\"1927-1979\"),\n                                g2 + ggtitle(\"1980-1989\"),\n                                g3 + ggtitle(\"1990-1999\"),\n                                g4 + ggtitle(\"2000-2009\"),\n                                g5 + ggtitle(\"2010-2016\"), \n                                nrow=2)\n      }\n    })\n    \n    output$dTable <- renderDataTable({\n      if (!is.null(tda_data())) {\n        dTab <- data.frame(tda_data()$td_data.title_year, tda_data()$td_data.movie_title, tda_data()$td_data.actor_1_name, tda_data()$td_data.actor_2_name, tda_data()$td_data.actor_3_name)\n        colnames(dTab) <- c(\"Year\", \"Title\", \"Actor1\", \"Actor2\", \"Actor3\") \n        dTab <- unique(dTab[order(dTab[,1]),])\n        rownames(dTab) <- NULL\n        dTab\n      }\n    },options = list(\n      autoWidth = TRUE, scrollX=TRUE, pageLength=6,\n      columnDefs = list(list(width = '5px', targets = 1))\n      #columnDefs = list(list(width = '100px', targets = \"_all\"))\n    ))\n    \n    output$tdPlots <- renderPlot({\n      if (!is.null(tda_data())) {\n        td_actors <- data.frame(tda_data()$td_data.movie_title, tda_data()$td_data.actor_1_name, tda_data()$td_data.actor_2_name, tda_data()$td_data.actor_3_name)\n        colnames(td_actors)[1] <- \"actor\"\n        # co-actors\n        td_co_actors <- melt(td_actors, id.vars = \"actor\")\n        names(td_co_actors) <- c(\"movie_title\", \"a_num\", \"actor\")\n        # add years\n        td_years <- data.frame(year=tda_data()[match(td_co_actors$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_actor <- cbind(td_co_actors[,3], td_years)\n        tda_actor <- aggregate(year ~ ., tda_actor, toString)\n        #tda_actor <- as.data.frame(td_co_actors[,3], stringsAsFactors = FALSE)\n        #tda_actor <- unique(tda_actor)\n        tda_actor <- tda_actor[ order(tda_actor[,1]), ]\n        actors_id <- 1:(nrow(tda_actor))\n        # nodes\n        tda_nodes <- data.frame(actors_id, tda_actor)\n        colnames(tda_nodes) <- c(\"id\", \"name\", \"years\")\n        tda_nodes$name <- as.character(tda_nodes$name)\n        rownames(tda_nodes) <- NULL\n        \n        td_links <- td_co_actors[,c(1,3)]\n        names(td_links) <- c(\"movie_title\", \"name\")\n        # change name column 2 to id as from actors_nodes\n        td_links_id <- data.frame(movie_title=td_links$movie_title, id= tda_nodes[match(td_links$name, tda_nodes$name), 1])\n        td_links_merge <- merge(x=td_links_id, y=td_links_id, by=\"movie_title\")\n        td_links_merge <- subset(td_links_merge, td_links_merge$id.x != td_links_merge$id.y)\n        # add years\n        td_years <- data.frame(year=tda_data()[match(td_links_merge$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_links <- as.data.frame(c(td_links_merge[,c(2,3)], td_years), stringsAsFactors = FALSE)\n        # sort links\n        tda_links <- tda_links[ order(tda_links[,1], tda_links[,2]), ]\n        names(tda_links) <- c(\"from\", \"to\", \"year\")\n        rownames(tda_links) <- NULL\n        \n        tda_links$timebins <- as.numeric(cut(tda_links$year, breaks=length(unique(tda_links$year))))\n        # Fading\n        edgesAnim <- lapply(1:10, function(i) {\n          tda_links$timebins <- tda_links$timebins + i;\n          tda_links$delay <- i;\n          tda_links\n        })\n        tda_links$delay <- 0\n        edgesAnim <- rbind(tda_links, do.call(rbind, edgesAnim))\n        edgesGraph <- graph_from_data_frame(edgesAnim, directed=F)\n        # Original Layout\n        SubGr <- subgraph.edges(edgesGraph, which(E(edgesGraph)$delay == 0))\n        V(SubGr)$degree <- igraph::degree(SubGr)\n        V(SubGr)$group <- igraph::cluster_edge_betweenness(subGr)$membership\n        lay <- create_layout(SubGr, 'igraph', algorithm=\"lgl\")\n        \n        attr(lay, 'graph') <- edgesGraph\n        \n        # Create graph with timebins as frame\n        p <- ggraph(data=lay) +\n          geom_node_point(aes(size=degree, colour = factor(group))) +\n          geom_edge_link0(aes(frame=timebins, alpha=delay, width=delay, colour=factor(node1.group)), data = gEdges(nodePar=\"group\")) +\n          scale_edge_alpha(range=c(0,1), guide = \"none\") +\n          scale_edge_width(range=c(0.5,1.5), trans=\"exp\", guide = \"none\") +\n          scale_size(guide = \"none\") +\n          ggforce::theme_no_axes() +\n          theme(plot.background = element_rect(fill=\"#000000\"),\n                panel.background = element_blank(),\n                panel.border = element_blank(),\n                plot.title = element_text(color = \"#000000\"),\n                legend.position = \"none\")\n       p \n       \n       # animation\n       \n       animation::ani.options(interval=0.2)\n       gganimation(p, \"animation.mp4\", title_frame=FALSE)\n       \n        # # Setup network\n        # net <- network(tda_links,  vertex.attr=tda_nodes, matrix.type=\"edgelist\", \n        #                loops=F, multiple=F, ignore.eval = F)\n        # # Setup initial layout\n        # x <- gplot.layout.fruchtermanreingold(net, NULL)\n        # net %v% \"x\" <- x[,1]\n        # net %v% \"y\" <- x[,2]\n        # \n        # guide <- guides(color = FALSE, size = FALSE)\n        # # A temp file to save the output.\n        # # This file will be removed later by renderImage\n        # #outfile <- tempfile(fileext = '.gif')\n        # ani.record(reset = TRUE)\n        # # Generate the PNG\n        # #png(outfile, width = 600, height = 400)\n        # saveGIF(\n        #       for (t in c(min(tda_links$year):max(tda_links$year))){\n        #         t_value <- c()\n        #         for (i in tda_nodes$years) {\n        #           c <- unlist(strsplit(i, \",\"))\n        #           if (any(trimws(c) %in% t)) {\n        #             t_value <- c(t_value, 1)\n        #           }\n        #           else {\n        #             t_value <- c(t5_value, 2)\n        #           }\n        #         }\n        #         net %v% 't' <- t_value \n        #         net %v% \"color\" = ifelse(net %v% \"t\" == \"1\", \"purple\", \"lightgray\")\n        #         g = ggnet2(net, mode=c(\"x\",\"y\"), size = \"degree\", label=T, label.size = 4, label.color=\"white\", edge.color = c(\"color\", \"grey50\"), color = \"purple\") + guide\n        #         #p <- ggplot(net, aes(x = from, y = to, xend = to-1, yend = from+1, frame= tda_links$year))\n        #         #saveGIF(g,filename=paste0(\"output_\",t,\".png\", sep=\"\"))\n        #         #ani.record()\n        #       }, movie.name = 'random.gif', interval = 0.1)\n        #     file.rename('random.gif', file)\n        #  \n        # #saveGIF(ani.replay(), img.name = \"record_plot\")\n        # #p <- ggplot(tda_links, aes(x = from, y = to, xend = from, yend = to, frame=year))\n        # \n        # #gganimate(p,\"outfile.gif\", title_frame =FALSE)\n        # \n        # #dev.off()\n        # \n        # # Return a list containing the filename\n        # list(src = \"outfile.gif\",\n        #      contentType = 'image/gif',\n        #      width = 600,\n        #      height = 400,\n        #      alt = \"Temporal Dynamic Analysis\")\n          }\n    })#, deleteFile = TRUE)\n    \n    output$ndtvPlots <- renderPlot({\n      if (!is.null(tda_data())) {\n        \n        td_actors <- data.frame(tda_data()$td_data.movie_title, tda_data()$td_data.actor_1_name, tda_data()$td_data.actor_2_name, tda_data()$td_data.actor_3_name)\n        colnames(td_actors)[1] <- \"actor\"\n        # co-actors\n        td_co_actors <- melt(td_actors, id.vars = \"actor\")\n        names(td_co_actors) <- c(\"movie_title\", \"a_num\", \"actor\")\n        # add years\n        td_years <- data.frame(year=tda_data()[match(td_co_actors$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_actor <- cbind(td_co_actors[,3], td_years)\n        tda_actor <- aggregate(year ~ ., tda_actor, toString)\n        #tda_actor <- as.data.frame(td_co_actors[,3], stringsAsFactors = FALSE)\n        #tda_actor <- unique(tda_actor)\n        tda_actor <- tda_actor[ order(tda_actor[,1]), ]\n        actors_id <- 1:(nrow(tda_actor))\n        # nodes\n        tda_nodes <- data.frame(actors_id, tda_actor)\n        colnames(tda_nodes) <- c(\"id\", \"name\", \"years\")\n        tda_nodes$name <- as.character(tda_nodes$name)\n        rownames(tda_nodes) <- NULL\n        \n        td_links <- td_co_actors[,c(1,3)]\n        names(td_links) <- c(\"movie_title\", \"name\")\n        # change name column 2 to id as from actors_nodes\n        td_links_id <- data.frame(movie_title=td_links$movie_title, id= tda_nodes[match(td_links$name, tda_nodes$name), 1])\n        td_links_merge <- merge(x=td_links_id, y=td_links_id, by=\"movie_title\")\n        td_links_merge <- subset(td_links_merge, td_links_merge$id.x != td_links_merge$id.y)\n        # add years\n        td_years <- data.frame(year=tda_data()[match(td_links_merge$movie_title, tda_data()$td_data.movie_title), 7])\n        tda_links <- as.data.frame(c(td_links_merge[,c(2,3)], td_years, td_years), stringsAsFactors = FALSE)\n        # sort links\n        tda_links <- tda_links[ order(tda_links[,1], tda_links[,2]), ]\n        names(tda_links) <- c(\"tail\", \"head\", \"onset\", \"terminus\")\n        rownames(tda_links) <- NULL\n        \n        # Dynamic network\n        node_onset <- as.data.frame(do.call(rbind, lapply(strsplit(as.character(tda_nodes$years), split=\",\"), function(y) min(as.numeric(y)))))\n        node_terminus <- as.data.frame(do.call(rbind, lapply(strsplit(as.character(tda_nodes$years), split=\",\"), function(y) max(as.numeric(y)))))\n        vs <- data.frame(onset=node_onset, terminus=node_terminus+1, vertex.id=tda_nodes[,1], name = tda_nodes[,2])\n        colnames(vs) <- c(\"onset\", \"terminus\", \"id\", \"name\")\n        vs$name <- as.character(vs$name)\n        es <- data.frame(onset=tda_links[,3], terminus=tda_links[,3]+1, \n                         tail=tda_links[,1], head=tda_links[,2])\n        # Network ---start---\n        # net_nodes <- data.frame(tda_nodes[,1:2], str_count(tda_nodes[, 3], \"\\\\d+\"))\n        # colnames(net_nodes) <- c(\"id\", \"name\", \"cnt\")\n        # net_links <- data.frame(tda_links[,1:2])\n        # colnames(net_links) <- c(\"from\", \"to\")\n        # net <- network(net_links, vertex.attrnames = net_nodes)\n        # net %v% \"actor\" <- net_nodes$name\n        # net %v% \"count\" <- net_nodes$cnt\n        # dnet <- networkDynamic(base.net = net, vertex.spells = vs, edge.spells = es)\n        # compute.animation(dnet, animation.mode = \"kamadakawai\",  \n        #                   slice.par=list(start=min(es$onset), end=max(es$terminus), interval=1,\n        #                                  aggregate.dur=1, rule='any'))\n        # colfunc <- colorRampPalette(brewer.pal(8,\"Set2\"))\n        # render.d3movie(dnet, usearrows = F, displaylabels= T,\n        #                label = net %v% 'actor',\n        #                bg='#c0c0c0', vertex.border=\"#dddddd\", edge.col = '#55555599',\n        #                #vertex.cex = rescale(str_count(tda_nodes[match(tda_nodes$id, td_net3 %v% \"vertex.names\"), 3], \"\\\\d+\"), c(1,4)),\n        #                #vertex.col = colfunc(nrow(es)),\n        #                vertex.col = \"#000000\",\n        #                vertex.tooltip = paste(\"<b>Actor:</b>\", net %v% 'actor'),\n        #                #edge.lwd = (td_net3 %e% \"weight\")/3,\n        #                output.mode='htmlWidget')\n        # \n        # Network ---end---\n        \n        td_net3 <- networkDynamic(vertex.spells=vs,\n                                  edge.spells=es)\n        td_net3 %v% 'name' <- vs$name\n        # make it discrete \n        #Eset.network.attribute(td_net3,'net.obs.period',list(mode=\"discrete\", time.increment=1,time.unit=\"year\"))\n        colfunc <- colorRampPalette(brewer.pal(7,\"Accent\"))\n        #par(mfrow=c(2,2))\n        #plot(td_net3, vertex.cex=3, vertex.col=colfunc(nrow(es)), layout=layout.circle)\n        #colfunc <- colorRampPalette(brewer.pal(8,\"Set2\"))\n        #dev.off()\n        x <- gplot.layout.target(td_net3, NULL)\n        td_net3 %v% \"x\" <- x[,1]\n        td_net3 %v% \"y\" <- x[,2]\n        \n        # cols <- colorRampPalette(brewer.pal(6,\"Blues\"))\n        # es1 <- subset(es, es$onset >= 1927 & es$onset <= 1979)\n        # es2 <- subset(es, es$onset >= 1980 & es$onset <= 1989)\n        # es3 <- subset(es, es$onset >= 1990 & es$onset <= 1999)\n        # es4 <- subset(es, es$onset >= 2000 & es$onset <= 2009)\n        # es5 <- subset(es, es$onset >= 2010 & es$onset <= 2016)\n        # counter <- 0\n        # if (nrow(es1) > 0) counter <- counter + 1\n        # if (nrow(es2) > 0) counter <- counter + 1\n        # if (nrow(es3) > 0) counter <- counter + 1\n        # if (nrow(es4) > 0) counter <- counter + 1\n        # if (nrow(es5) > 0) counter <- counter + 1\n        # par(mfrow=c(1,counter))\n        # \n        # if (nrow(es1) > 0) {\n        #     # network from 1927 to 1979\n        #     dnet1 <- networkDynamic(vertex.spells = vs, edge.spells = es1)\n        #     plot(network.extract(dnet1, onset=1927, terminus=1979), \n        #          vertex.cex = 4, label.cex=0.6,  \n        #          #vertex.cex = rescale(str_count(tda_nodes[match(tda_nodes$id, td_net3 %v% \"vertex.names\"), 3]), c(2,5)),\n        #          vertex.col = cols(nrow(es)), label.pos = 5,\n        #          displaylabel=T, main=paste0(1927, \"-\", 1979))\n        #   }\n        #   \n        # \n        # # Network from 1980 to 1989\n        # if (nrow(es2) > 0)\n        # {\n        #   dnet2 <- networkDynamic(vertex.spells = vs, edge.spells = es2)\n        #   plot(network.extract(td_net3, onset=1980, terminus=1989), \n        #        vertex.cex = 4, label.cex=0.6,  \n        #        #vertex.cex = rescale(str_count(tda_nodes[match(tda_nodes$id, td_net3 %v% \"vertex.names\"), 3]), c(2,5)),\n        #        vertex.col = cols(nrow(es)), label.pos = 5,\n        #        displaylabel=T, main=paste0(1980, \"-\", 1989))\n        # }\n        # \n        # # Network from 1990 to 1999\n        # if (nrow(es3) > 0)\n        # {\n        #   dnet3 <- networkDynamic(vertex.spells = vs, edge.spells = es3)\n        #   plot(network.extract(dnet3, onset=1990, terminus=1999), \n        #        vertex.cex = 4, label.cex=0.6,  \n        #        #vertex.cex = rescale(str_count(tda_nodes[match(tda_nodes$id, td_net3 %v% \"vertex.names\"), 3]), c(2,5)),\n        #        vertex.col = cols(nrow(es)), label.pos = 5,\n        #        displaylabel=T, main=paste0(1990, \"-\", 1999))\n        # }\n        # \n        # # Network from 2000 to 2009\n        # if (nrow(es4) > 0)\n        # {\n        #   dnet4 <- networkDynamic(vertex.spells = vs, edge.spells = es4)\n        #   plot(network.extract(dnet4, onset=2000, terminus=2009), \n        #        vertex.cex = 4, label.cex=0.6,  \n        #        #vertex.cex = rescale(str_count(tda_nodes[match(tda_nodes$id, td_net3 %v% \"vertex.names\"), 3]), c(2,5)),\n        #        vertex.col = cols(nrow(es)), label.pos = 5,\n        #        displaylabel=T, main=paste0(2000, \"-\", 2009)) \n        # }\n        #    \n        # # Network from 2010 to 2016\n        # if (nrow(es5) > 0) {\n        #   dnet5 <- networkDynamic(vertex.spells = vs, edge.spells = es5)\n        #   plot(network.extract(dnet5, onset=2010, terminus=2016), \n        #        vertex.cex = 4, label.cex=0.6,  \n        #        #vertex.cex = rescale(str_count(tda_nodes[match(tda_nodes$id, td_net3 %v% \"vertex.names\"), 3]), c(2,5)),\n        #        vertex.col = cols(nrow(es)), label.pos = 5,\n        #        displaylabel=T, main=paste0(2010, \"-\", 2016)) \n        # }\n        #    \n        # \n        #}\n        # par(mfrow=c(1,2))\n        # midY <- (max(es$onset) - min(es$onset))/2 + min(es$onset)\n        # plot(network.extract(td_net3, onset=min(es$onset), terminus=midY), displaylabel=T, main=paste0(min(es$onset), \"-\", midY))\n        # plot(network.extract(td_net3, onset=midY, terminus=max(es$onset)), displaylabel=T, main=paste0(midY, \"-\", max(es$onset)))\n        # \n        # filmstrip(td_net3, displaylabels=T, mfrow=c(1, 5),\n        #           slice.par=list(start=1970, end=2016, interval=10, \n        #                          aggregate.dur=10, rule='any'))\n        compute.animation(td_net3, animation.mode = \"kamadakawai\", layout.par = c(\"x\", \"y\"),\n                          slice.par=list(start=min(es$onset), end=max(es$terminus), interval=1,\n                                         aggregate.dur=1, rule='any'))\n\n        colfunc <- colorRampPalette(brewer.pal(7,\"Accent\"))\n        render.d3movie(td_net3, usearrows = F, displaylabels= T,\n                       #label=vs[match(vs$id, td_net3 %v% \"vertex.names\"), 4],\n                       bg='#c0c0c0', vertex.border=\"#dddddd\", edge.col = '#fd9696',\n                       #vertex.cex = rescale(str_count(tda_nodes[match(tda_nodes$id, td_net3 %v% \"vertex.names\"), 3], \"\\\\d+\"), c(1,4)),\n                       vertex.cex = 3,\n                       vertex.col = colfunc(nrow(es)),\n                       vertex.col = \"#000000\",\n                       #vertex.tooltip = paste(\"<b>Actor:</b>\", (vs[match(vs$id, td_net3 %v% \"vertex.names\"), 4])),\n                       edge.lwd = 2,\n                       #edge.col = \"#fd9696\",\n                       #edge.lwd = (td_net3 %e% \"weight\")/3,\n                       output.mode='htmlWidget',\n                       script.type='embedded', \n                       launchBrowser=TRUE)\n        # detach(\"package:ndtv\")\n        # detach(\"package:sna\")\n        # detach(\"package:networkDynamic\")\n        # detach(\"package:network\")\n        # detach(\"package:animation\")\n      }})\n    \n    output$tdHeader <- renderText({\n      if (!is.null(tda_data())) {\n        paste0(td_actor() ,\" Co-starring data tables\")\n      }\n    })\n    \n    output$actHeader <- renderText({\n      if (!is.null(tda_data())) {\n        paste0(\"Number of \",td_actor() ,\"'s movies vs years \")\n      }\n    })\n    \n    output$ggHeader <- renderText({\n      if (!is.null(tda_data())) {\n        paste0(td_actor() ,\" small multiple visualisation\")\n      }\n    })\n    \n    output$gtHeader <- renderText({\n      if (!is.null(tda_data())) {\n        paste0(td_actor() ,\" genres trend analysis with streamgraph\")\n      }\n    })\n    \n    output$barHeader <- renderText({\n      if (!is.null(tda_data())) {\n        paste0(td_actor() ,\" genres trend analysis with bar plot\")\n      }\n    })\n    \n    output$sbHeader <- renderText({\n      if (!is.null(tda_data())) {\n        paste0(td_actor() ,\" collaboration with directors and movies\")\n      }\n    })\n    \n    # Sunburst of actor, movie and director\n    output$sunburst <- renderSunburst({\n        if (!is.null(tda_data())) {\n              amd_actor <- gsub('-', \"_\", td_actor())\n              amd_movie <- gsub('-', \"_\", tda_data()$td_data.movie_title)\n              amd_director <- gsub('-', \"_\", tda_data()$td_data.director_name)\n              amd_gross <- gsub('-', \"_\", round(tda_data()$td_data.gross/1000000),0)\n              amd_paste <- paste(amd_actor,amd_director, amd_movie,sep='-')\n              #sb_amd <- unique(data.frame(amd_paste, rep(1, length(amd_paste))))\n              sb_amd <- unique(data.frame(amd_paste, amd_gross))\n              sb_amd <- sb_amd[order(sb_amd[,2]),]\n              add_shiny(sunburst(sb_amd, explanation=\"function(d){return d.data.amd_actor}\", percent = FALSE))\n        }\n    })\n    selection <- reactive({\n        input$sunburst_mouseover\n    })\n    output$selection <- renderText(selection())\n    \n    # Streamgraph\n    \n    output$stream <- renderStreamgraph({\n      \n        #if (!is.null(tda_data())) {\n          genres_year <- data.frame(imdb_data$title_year, imdb_data$genres) \n          colnames(genres_year) <- c(\"year\", \"genres\")\n          \n          genres_split <- strsplit(as.character(genres_year$genres), split=\"\\\\|\")\n          genres_year_split <- data.frame(year = rep(genres_year$year, sapply(genres_split, length)), genre = unlist(genres_split), stringsAsFactors = FALSE)\n          genres_year_split <- cbind(genres_year_split, rep(1, nrow(genres_year_split)))\n          colnames(genres_year_split)[3] <- \"n\"\n          genres_year_agg <- aggregate(n ~ genres_year_split$year + genres_year_split$genre, data = genres_year_split, length)\n          colnames(genres_year_agg) <- c(\"year\", \"genre\", \"n\")\n          sorted_genres_year <- na.omit(genres_year_agg[ order(c(genres_year_agg$year, genres_year_agg$genre)), ])\n          all_genres_year <- as.data.frame(xtabs(n~year+genre, sorted_genres_year))\n          all_genres_year$year <- as.numeric(as.character(all_genres_year$year))\n          colnames(all_genres_year) <- c(\"year\", \"genre\", \"n\")\n          # Update slider input years\n          sub_genres_year <- subset(all_genres_year, all_genres_year$year >= years()[1] & all_genres_year$year <= years()[2])\n          cols <- colorRampPalette(brewer.pal(8, \"Accent\"))(length(unique(all_genres_year$genre)))\n          \n          streamgraph(sub_genres_year, \"genre\", \"n\", \"year\") %>% sg_fill_brewer(\"Set3\")\n          #eval(call_new(streamgraph, Data(), input$label, input$n, input$t))\n        #}\n    })\n    \n    output$activeYear <- renderPlot({\n      \n      if (!is.null(tda_data())) {\n        title_year <- data.frame(tda_data()$td_data.title_year, tda_data()$td_data.movie_title, tda_data()$td_data.genres) \n        title_year <- title_year[order(title_year[,1]),]\n        colnames(title_year) <- c(\"year\", \"title\", \"genres\")\n        ty <- data.table(title_year)\n        ty[ , count := 1:.N , by = \"year\" ]\n        genres_years <- ty[,c(1,3,4)] \n        \n        genres_split <- strsplit(as.character(genres_years$genres), split=\"\\\\|\")\n        genres_years_split <- data.frame(year = rep(genres_years$year, sapply(genres_split, length)), count = rep(1/sapply(genres_split, length), sapply(genres_split, length)),genre = unlist(genres_split), stringsAsFactors = FALSE)\n        \n        cols <- colorRampPalette(brewer.pal(8, \"Accent\"))(length(unique(genres_years_split$genre)))\n        # The palette with grey:\n        g <- ggplot(genres_years_split, aes(x = year, y = count, group = year, fill = genre)) + \n          geom_bar(stat=\"identity\") + theme_classic() + scale_fill_manual(values=cols) \n        g\n      }\n    })\n    \n    rv <- reactiveValues(func=NULL) \n    \n    \n    \n    Gyear <- reactive({\n      if (!is.null(tda_data())) {\n        minY <- min(tda_data()$td_data.title_year)\n        maxY <- max(tda_data()$td_data.title_year)\n        val1 <- max(minY, input$Gyears[1])\n        val2 <- min(maxY, input$Gyears[2])\n        valueY <- c(val1, val2)\n        updateSliderInput(session, \"Gyears\", min = minY, max = maxY, value=valueY)\n        \n        input$Gyears\n      }  \n    })\n    \n    observeEvent(input$search,{ \n      if (!is.null(tda_data())) {\n        minY <- min(tda_data()$td_data.title_year)\n        maxY <- max(tda_data()$td_data.title_year)\n        updateSliderInput(session, \"Gyears\", min = minY, max = maxY, value=c(minY, maxY))\n        \n      }  \n      \n      \n    })\n    \n    \n    output$lgnet <- renderPlot({\n      genres_data <- subset(imdb_data, imdb_data$title_year >= movie_years()[1] &\n                              imdb_data$title_year <= movie_years()[2])\n      if (!str_detect(movie_genres(), \"All\")) {\n        genres_data <- genres_data[grep(movie_genres(), genres_data$genres),]}\n      genres_title <- data.frame(genres_data$movie_title, genres_data$genres) \n      colnames(genres_title) <- c(\"titler\", \"genres\")\n      genres_split <- strsplit(as.character(genres_title$genres), split=\"\\\\|\")\n      genres_title_split <- data.frame(title = rep(genres_title$title, sapply(genres_split, length)), genre = unlist(genres_split), stringsAsFactors = FALSE)\n      # Add gross to a column\n      genre_gross <- data.frame(gross=genres_data[match(genres_title_split $title, genres_data$movie_title), 9])\n      gtg <- as.data.frame(c(genres_title_split[,c(1,2)], genre_gross), stringsAsFactors = FALSE)\n      gtg <- gtg[ order(-gtg[,3]), ]\n      rownames(gtg) <- NULL\n      # Get the last occurence index of the movies\n      i <- which(!duplicated(gtg[,1],fromLast=T))\n      # Filter the top 20 movies\n      top20_gtg <- gtg[c(1:i[20]),]\n      # Generate nodes and links\n      two_mode_nodes <- unique(data.frame(id = c(as.matrix(top20_gtg[,1:2]))))\n      two_mode_nodes$id <- as.character(two_mode_nodes$id)\n      two_mode_nodes$type <- ifelse(two_mode_nodes[,1] %in%  genreList, 1, NA)\n      two_mode_nodes <- two_mode_nodes[ order(-two_mode_nodes[,2], two_mode_nodes[,1]),]\n      rownames(two_mode_nodes) <- NULL\n      genreList <- unique(genres_title_split$genre)\n      # Generate links\n      tm_links <- top20_gtg[,c(2,1)]\n      #gglinks\n      gg_links <- cbind(tm_links, type=rep(\"genres\", nrow(tm_links)))\n      m <- as.matrix(table(tm_links))\n      M <- m[, colnames(m) %in% unique(top20_gtg[,1])]\n      two_mode_links <- rbind(M)\n      net2 <- graph_from_incidence_matrix(two_mode_links)\n      table(V(net2)$type)\n      #plot(net2, vertex.label=NA)\n      # Genres are blue squares, movie nodes are orange circles:\n      V(net2)$color <- c(\"steel blue\", \"orange\")[V(net2)$type+1]\n      V(net2)$shape <- c(\"square\", \"none\")[V(net2)$type+1]\n      # Genres will have name labels, movie nodes  will not:\n      V(net2)$label <- \"\"\n      V(net2)$label[V(net2)$type==F] <- two_mode_nodes$id[V(net2)$type==F] \n      V(net2)$label[V(net2)$type==T] <- two_mode_nodes$id[V(net2)$type==T] \n      V(net2)$label.cex=0.6\n      V(net2)$label.font=1\n      l <- layout_with_kk(net2)\n      \n      \n      \n      #png(\"network.png\",height=260, width=400)\n      #coords <- layout.auto(net2)\n      par(mar=c(0,0,0,0))\n      plot(net2, vertex.label.color=ifelse(V(net2)$type,\"black\", \"white\"), vertex.size=(2-V(net2)$type)*10, vertex.label.degree=pi/2,\n           layout=l) \n      \n    })\n      \n    \n    output$gennet <- renderPlot({\n      genres_data <- subset(imdb_data, imdb_data$title_year >= movie_years()[1] &\n                              imdb_data$title_year <= movie_years()[2])\n      if (!str_detect(movie_genres(), \"All\")) {\n        genres_data <- genres_data[grep(movie_genres(), genres_data$genres),]}\n      genres_title <- data.frame(genres_data$movie_title, genres_data$genres) \n      colnames(genres_title) <- c(\"titler\", \"genres\")\n      genres_split <- strsplit(as.character(genres_title$genres), split=\"\\\\|\")\n      genres_title_split <- data.frame(title = rep(genres_title$title, sapply(genres_split, length)), genre = unlist(genres_split), stringsAsFactors = FALSE)\n      # Add gross to a column\n      genre_gross <- data.frame(gross=genres_data[match(genres_title_split $title, genres_data$movie_title), 9])\n      gtg <- as.data.frame(c(genres_title_split[,c(1,2)], genre_gross), stringsAsFactors = FALSE)\n      gtg <- gtg[ order(-gtg[,3]), ]\n      rownames(gtg) <- NULL\n      # Get the last occurence index of the movies\n      i <- which(!duplicated(gtg[,1],fromLast=T))\n      # Filter the top 20 movies\n      top20_gtg <- gtg[c(1:i[20]),]\n      # Generate nodes and links\n      two_mode_nodes <- unique(data.frame(id = c(as.matrix(top20_gtg[,1:2]))))\n      two_mode_nodes$id <- as.character(two_mode_nodes$id)\n      two_mode_nodes$type <- ifelse(two_mode_nodes[,1] %in%  genreList, 1, NA)\n      two_mode_nodes <- two_mode_nodes[ order(-two_mode_nodes[,2], two_mode_nodes[,1]),]\n      rownames(two_mode_nodes) <- NULL\n      genreList <- unique(genres_title_split$genre)\n      # Generate links\n      tm_links <- top20_gtg[,c(2,1)]\n      #gglinks\n      gg_links <- cbind(tm_links, type=rep(\"genres\", nrow(tm_links)))\n      m <- as.matrix(table(tm_links))\n      M <- m[, colnames(m) %in% unique(top20_gtg[,1])]\n      two_mode_links <- rbind(M)\n      net2 <- graph_from_incidence_matrix(two_mode_links)\n      table(V(net2)$type)\n      #plot(net2, vertex.label=NA)\n      # Genres are blue squares, movie nodes are orange circles:\n      V(net2)$color <- c(\"steel blue\", \"orange\")[V(net2)$type+1]\n      V(net2)$shape <- c(\"square\", \"circle\")[V(net2)$type+1]\n      # Genres will have name labels, movie nodes  will not:\n      V(net2)$label <- \"\"\n      V(net2)$label[V(net2)$type==F] <- two_mode_nodes$id[V(net2)$type==F] \n      #V(net2)$label[V(net2)$type==T] <- two_mode_nodes$id[V(net2)$type==T] \n      V(net2)$label.cex=0.6\n      V(net2)$label.font=1.5\n      l <- layout_with_kk(net2)\n      \n      \n      \n      #png(\"network.png\",height=260, width=400)\n      #coords <- layout.auto(net2)\n      par(mar=c(0,0,0,0))\n      plot(net2, vertex.label.color=\"white\", vertex.size=(2-V(net2)$type)*8, \n          layout=l)\n      #dev.off() \n    }, height=200, width=300)\n    \n    output$bundleId <- renderEdgebundle({\n      genres_data <- subset(imdb_data, imdb_data$title_year >= movie_years()[1] &\n                              imdb_data$title_year <= movie_years()[2])\n      if (!str_detect(movie_genres(), \"All\")) {\n        genres_data <- genres_data[grep(movie_genres(), genres_data$genres),]}\n      genres_title <- data.frame(genres_data$movie_title, genres_data$genres) \n      colnames(genres_title) <- c(\"titler\", \"genres\")\n      genres_split <- strsplit(as.character(genres_title$genres), split=\"\\\\|\")\n      genres_title_split <- data.frame(title = rep(genres_title$title, sapply(genres_split, length)), genre = unlist(genres_split), stringsAsFactors = FALSE)\n      # Add gross to a column\n      genre_gross <- data.frame(gross=genres_data[match(genres_title_split $title, genres_data$movie_title), 9])\n      gtg <- as.data.frame(c(genres_title_split[,c(1,2)], genre_gross), stringsAsFactors = FALSE)\n      gtg <- gtg[ order(-gtg[,3]), ]\n      rownames(gtg) <- NULL\n      # Get the last occurence index of the movies\n      i <- which(!duplicated(gtg[,1],fromLast=T))\n      # Filter the top 20 movies\n      top20_gtg <- gtg[c(1:i[20]),]\n      # Generate nodes and links\n      two_mode_nodes <- unique(data.frame(id = c(as.matrix(top20_gtg[,1:2]))))\n      two_mode_nodes$id <- as.character(two_mode_nodes$id)\n      two_mode_nodes$type <- ifelse(two_mode_nodes[,1] %in%  genreList, 1, NA)\n      two_mode_nodes <- two_mode_nodes[ order(-two_mode_nodes[,2], two_mode_nodes[,1]),]\n      rownames(two_mode_nodes) <- NULL\n      genreList <- unique(genres_title_split$genre)\n      # Generate links\n      tm_links <- top20_gtg[,c(2,1)]\n      #gglinks\n      gg_links <- cbind(tm_links, type=rep(\"genres\", nrow(tm_links)))\n      m <- as.matrix(table(tm_links))\n      M <- m[, colnames(m) %in% unique(top20_gtg[,1])]\n      two_mode_links <- rbind(M)\n      net2 <- graph_from_incidence_matrix(two_mode_links)\n      table(V(net2)$type)\n      #plot(net2, vertex.label=NA)\n      # Genres are blue squares, movie nodes are orange circles:\n      V(net2)$color <- c(\"steel blue\", \"orange\")[V(net2)$type+1]\n      V(net2)$shape <- c(\"square\", \"circle\")[V(net2)$type+1]\n      # Genres will have name labels, movie nodes  will not:\n      V(net2)$label <- \"\"\n      V(net2)$label[V(net2)$type==F] <- two_mode_nodes$id[V(net2)$type==F] \n      #V(net2)$label[V(net2)$type==T] <- two_mode_nodes$id[V(net2)$type==T] \n      V(net2)$label.cex=0.6\n      V(net2)$label.font=1.5\n      #l <- layout_with_kk(net2)\n      e <- edgebundle(net2,tension = 0.1,fontsize = 20)\n      print(e)\n      \n      \n    })\n    \n    output$stackPlot <- renderPlot({\n      #if (!is.null(tda_data())) {\n        # minGross <- as.integer(gross()[1] * 1000000)\n        # maxGross <- as.integer(gross()[2] * 1000000)\n      \n        genres_data <- subset(imdb_data, imdb_data$title_year >= movie_years()[1] &\n                              imdb_data$title_year <= movie_years()[2])\n        if (!str_detect(movie_genres(), \"All\")) {\n          genres_data <- genres_data[grep(movie_genres(), genres_data$genres),]}\n        genres_year <- data.frame(genres_data$title_year, genres_data$genres) \n        colnames(genres_year) <- c(\"year\", \"genres\")\n        \n        genres_split <- strsplit(as.character(genres_year$genres), split=\"\\\\|\")\n        genres_year_split <- data.frame(year = rep(genres_year$year, sapply(genres_split, length)), genre = unlist(genres_split), stringsAsFactors = FALSE)\n        genres_year_split <- cbind(genres_year_split, rep(1, nrow(genres_year_split)))\n        colnames(genres_year_split)[3] <- \"n\"\n        genres_year_agg <- aggregate(n ~ genres_year_split$year + genres_year_split$genre, data = genres_year_split, length)\n        colnames(genres_year_agg) <- c(\"year\", \"genre\", \"n\")\n        sorted_genres_year <- na.omit(genres_year_agg[ order(c(genres_year_agg$year, genres_year_agg$genre)), ])\n        all_genres_year <- as.data.frame(xtabs(n~year+genre, sorted_genres_year))\n        all_genres_year$year <- as.numeric(as.character(all_genres_year$year))\n        colnames(all_genres_year) <- c(\"year\", \"genre\", \"n\")\n        \n        ### Output freq words\n        freq_genres <- aggregate(all_genres_year$n ~ all_genres_year$genre, all_genres_year, FUN=sum)\n        colnames(freq_genres) <- c(\"genre\", \"freq\")\n        output$freqPlot <- renderPlot({\n          wordcloud(freq_genres$genre, freq_genres$freq, colors = brewer.pal(8, \"Dark2\"),scale=c(2.2,0.3))\n        })\n        # Update slider input years\n        #sub_genres_year <- subset(all_genres_year, all_genres_year$year >= years()[1] & all_genres_year$year <= years()[2])\n        colfunc<-colorRampPalette(brewer.pal(9,\"Set3\"))\n        #cols <- as.list(distinctColorPalette(length(unique(all_genres_year$genre))))\n        # Use ggplot\n        # ggplot(all_genres_year, aes(x = year, y = n, group = genre, fill = genre)) +\n        #   geom_area() + #scale_colour_gradientn(colours=rainbow(length(unique(all_genres_year$genre)))) +\n        #   scale_fill_hue() +\n        # theme(axis.text.x=element_text(angle=90,hjust=1), panel.border = element_blank(), panel.grid.major = element_blank(),\n        #       panel.grid.minor = element_blank(), panel.background = element_blank())\n        #cbPallete <- c(\"#89C5DA\", \"#DA5724\", \"#74D944\", \"#CE50CA\", \"#3F4921\", \"#C0717C\", \"#CD9BCD\", \"#5F7FC7\", \n        # \"#673770\", \"#8569D5\", \"#38333E\", \"#508578\", \"#D7C1B1\", \"#D3D93E\", \"#7FDCC0\")\n        cols <- colorRampPalette(brewer.pal(8, \"Accent\"))(length(unique(all_genres_year$genre)))\n        g <- ggplot(all_genres_year, aes(x = year, y = n, group = genre, fill = genre)) +\n          #stat_steamgraph() + scale_colour_gradientn(colours=cols) +\n          stat_steamgraph() + scale_fill_manual(values=cols) + \n          #stat_smooth(geom=\"area\", method=\"loess\", span=1/3) +\n          theme(panel.border = element_blank(), panel.grid.major = element_blank(),\n                panel.grid.minor = element_blank(), panel.background = element_blank())  \n                #coord_fixed(ratio = 0.2)\n          #ggtitle(\"Temporal Genre Trend Analysis\") +  #stat_smooth(geom = 'area') +\n          #theme(plot.title = element_text(family = \"Trebuchet MS\", color=\"#666666\", face=\"bold\", size=24, hjust=0))\n        #ggplotly(, tooltip = c(\"group\",))\n        #   #geom_ribbon(aes(ymin=0, ymax=n)) #+ scale_fill_brewer(palette=\"Set3\")  +\n        #theme(axis.text.x = element_text(angle = 90, hjust = 1))\n        g\n        \n        #ggvis(sorted_genres_year, x = ~year, y = ~n, fill= ~genre) %>% group_by(genre) %>% layer_ribbons()\n        \n      #}\n      \n        \n      })\n    \n    \n    output$barPlot <- renderPlot({\n      if (!is.null(tda_data())) {\n        genres_year <- data.frame(tda_data()$td_data.title_year, tda_data()$td_data.genres) \n        colnames(genres_year) <- c(\"year\", \"genres\")\n        \n        title_year <- data.frame(tda_data()$td_data.title_year, tda_data()$td_data.movie_title) \n        colnames(title_year) <- c(\"year\", \"title\")\n        agg_title <- aggregate(title ~ year, title_year, length)\n        \n        genres_split <- strsplit(as.character(genres_year$genres), split=\"\\\\|\")\n        genres_year_split <- data.frame(year = rep(genres_year$year, sapply(genres_split, length)), genre = unlist(genres_split), stringsAsFactors = FALSE)\n        genres_year_split <- cbind(genres_year_split, rep(1, nrow(genres_year_split)))\n        colnames(genres_year_split)[3] <- \"n\"\n        genres_year_agg <- aggregate(n ~ genres_year_split$year + genres_year_split$genre, data = genres_year_split, length)\n        colnames(genres_year_agg) <- c(\"year\", \"genre\", \"n\")\n        sorted_genres_year <- na.omit(genres_year_agg[ order(c(genres_year_agg$year, genres_year_agg$genre)), ])\n        all_genres_year <- as.data.frame(xtabs(n~year+genre, sorted_genres_year))\n        all_genres_year$year <- as.numeric(as.character(all_genres_year$year))\n        colnames(all_genres_year) <- c(\"year\", \"genre\", \"n\")\n        # Count number of title\n        title_sum <- data.frame(cnt=agg_title$title, year= all_genres_year[match(agg_title$year, all_genres_year$year), 1])\n        ty <- data.frame(title = rep(title_sum$cnt, sapply(genres_split, length)), genre = unlist(genres_split), stringsAsFactors = FALSE)\n        \n        \n        #wordcloud(all_genres_year$genre, all_genres_year$n)\n        #Update slider input years\n        sub_genres_year <- subset(all_genres_year, all_genres_year$year >= Gyear()[1] & all_genres_year$year <= Gyear()[2])\n        #colfunc<-colorRampPalette(brewer.pal(9,\"Set3\"))\n        cols <- colorRampPalette(brewer.pal(8, \"Accent\"))(length(unique(sub_genres_year$genre)))\n        g <- ggplot(sub_genres_year, aes(x = year, y = n, group = genre, fill = genre)) +\n          #geom_bar(stat=\"identity\") + theme_classic() + scale_fill_manual(values=cols)\n          stat_steamgraph() + scale_fill_manual(values=cols) + \n          theme(panel.border = element_blank(), panel.grid.major = element_blank(),\n                panel.grid.minor = element_blank(), panel.background = element_blank())  \n        g\n        \n        # if (!is.null(tda_data())) {\n        #   title_year <- data.frame(tda_data()$td_data.title_year, tda_data()$td_data.movie_title) \n        #   colnames(title_year) <- c(\"year\", \"title\")\n        #   agg_title <- aggregate(title ~ year, title_year, length)\n        #   \n        #   # The palette with grey:\n        #   g <- ggplot(agg_title, aes(x = year, y = title, group = year, fill = title)) + \n        #     geom_bar(stat=\"identity\") + theme_classic() + scale_colour_gradientn(colours=rainbow(4)) \n        #   g\n        # }\n      }\n      \n      \n    })\n    output$tooltips <- renderText({\n      if(is.null(input$plot_hover)) return(\"NULL\\n\")\n      hover=input$plot_hover\n      genre_tooltip = hover$group-all_genres_year$genre\n      paste0(\"genre =\", genre_tooltip)\n    })\n    # output$dynamic <- renderUI({\n    #   req(input$plot_hover) \n    #   verbatimTextOutput(\"vals\")\n    # })\n    # \n    # output$vals <- renderPrint({\n    #   hover <- input$plot_hover \n    #   # print(str(hover)) # list\n    #   y <- nearPoints(all_genres_year, input$plot_hover)[all_genres_year$genre]\n    #   req(nrow(y) != 0)\n    #   y\n    # })\n    \n    # Genres dygraph\n    # output$stack <- renderDygraph({\n    #   genres_year <- data.frame(tda_data()$td_data.title_year, tda_data()$td_data.genres) \n    #   colnames(genres_year) <- c(\"year\", \"genres\")\n    #   genres_split <- strsplit(as.character(genres_year$genres), split=\"\\\\|\")\n    #   genres_year_split <- data.frame(year = rep(genres_year$year, sapply(genres_split, length)), genre = unlist(genres_split), stringsAsFactors = FALSE)\n    #   genres_year_split <- cbind(genres_year_split, rep(1, nrow(genres_year_split)))\n    #   colnames(genres_year_split)[3] <- \"n\"\n    #   genres_year_agg <- aggregate(n ~ genres_year_split$year + genres_year_split$genre, data = genres_year_split, length)\n    #   colnames(genres_year_agg) <- c(\"year\", \"genre\", \"n\")\n    #   #na.omit(your.data.frame)\n    #   sorted_genres_year <- genres_year_agg[ order(c(genres_year_agg$year, genres_year_agg$genre)), ]\n    #   dygraph(sorted_genres_year, main=\"Genres total vs years\") %>% \n    #     dySeries(\"genre\", label = \"Genres\") %>%\n    #     dyOptions(stackedGraph = TRUE) %>%\n    #     dyRangeSelector(height = 20)\n    # })\n    \n    \n    # Dygraphs\n    # output$dg <- renderDygraph({\n    #   if (!is.null(tda_data())) {\n    #     ty <- data.frame(tda_data()$td_data.title_year, tda_data()$td_data.movie_title)\n    #     colnames(ty) <- c(\"year\", \"title\")\n    #     ty_sum <- aggregate(ty[2], ty[-2], length)\n    #     ty_sum <- ty_sum[order(ty_sum$year),]\n    #     dygraph(ty_sum, main=\"Titles vs years\") %>% \n    #       dySeries(\"title\", label = \"Titles\") %>%\n    #       dyOptions(stackedGraph = TRUE) %>%\n    #       dyRangeSelector(height = 20)\n    #   }\n    # })\n    \n    output$bubble <- bubbles::renderBubbles({\n      \n        if (!is.null(tda_data())) {\n            td_genres <- strsplit(as.character(tda_data()$td_data.genres), split=\"\\\\|\")\n            td_genres <- unlist(td_genres)\n            td_genres_sum <- as.data.frame(table(td_genres))\n            colnames(td_genres_sum) <- c(\"genre\", \"freq\")\n            colfunc<-colorRampPalette(brewer.pal(9,\"Set3\"))\n            bubbles(td_genres_sum$freq, td_genres_sum$genre\n            , color = colfunc(nrow(td_genres_sum)), textColor = \"grey40\")\n            #bubbles(td_genres_sum$freq, as.character(td_genres_sum$genre), tooltip = sprintf(\"%s: %d\", td_genres_sum$genre, td_genres_sum$freq))\n        }\n     })\n    \n    \n     \n    \n})\n",
    "created" : 1506320738089.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2124410515",
    "id" : "F1630C3B",
    "lastKnownWriteTime" : 1507511663,
    "last_content_update" : 1507511663955,
    "path" : "~/Documents/COMP5703/Shiny/Project/MoviePVA/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}